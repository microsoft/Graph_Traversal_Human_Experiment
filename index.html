<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Human Planning - Graph Traversal</title>

  <!-- Load the move and change states (kept for structure; not shown in trials) -->

  <script src="GT_stimuli_b1_full.js"></script>
  <script src="GT_stimuli_b2_full.js"></script>

  <!-- FileSaver for saving files -->
  <script src="https://cdn.jsdelivr.net/npm/file-saver"></script>

  <!-- JSZip for bundling puzzle logs + audio into one download -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background-color: #f9f9f9;
      color: #333;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
    }

    .site-footer {
      background-color: #f1f1f1;
      border-top: 1px solid #ccc;
      padding: 6px 20px;
      text-align: center;
      font-size: 0.8rem;
      color: #555;
      margin-top: auto; /* pushes footer to bottom */
      width: 100%;
    }

    .footer-content {
      display: flex;
      justify-content: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 24px;
      align-items: flex-start;
      width: 100%;
      max-width: 1200px;
    }

    .left-column {
      max-width: 420px;
      flex-shrink: 1;
      background-color: #ffffff;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      /* Remove min-height - let content determine height */
    }

    .stim-prompt{
      margin-top:12px;
      padding:10px 12px;
      border:1px solid #cfd8dc;
      border-radius:6px;
      background:#fafafa;
    }

    /* Style both practice and trial textareas the same */
    .notes-textarea, .practice-textarea{
      width:100%;
      min-height:260px;
      resize:vertical;
      padding:12px;
      font-size:16px;
      line-height:1.4;
      border:1px solid #cfd8dc;
      border-radius:6px;
      box-sizing:border-box;
    }
    .notes-textarea:focus, .practice-textarea:focus{
      outline:none;
      border-color:#42a5f5;
      box-shadow:0 0 0 3px rgba(66,165,245,.25);
    }

    .right-column {
      max-width: 700px;
      flex-shrink: 1;
      flex: 2;
      background-color: #ffffff;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      /* Remove min-height - let content determine height */
      display: flex;
      flex-direction: column;
      justify-content: center; /* center the Continue button in the white space */
      align-items: center;
      min-height: 280px; /* keep a pleasant white space area */
    }

    /* Countdown badge shown during trials (kept for structure; hidden in UI) */
    .trial-timer {
      align-self: flex-end;
      margin-bottom: 8px;
      padding: 6px 12px;
      border-radius: 9999px;
      border: 1px solid #a5d6a7;
      background: #e8f5e9;
      color: #1b5e20;
      font-weight: 600;
      font-size: 20px;
      letter-spacing: .5px;
      font-variant-numeric: tabular-nums;
    }
    .trial-timer.warning {
      border: 1px solid #ffe082;
      background: #fff8e1;
      color: #8d6e63;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .trial-timer.urgent {
      background: #ffebee;
      border-color: #ef9a9a;
      color: #b71c1c;
    }

    .rules-text {
      border-left: 6px solid #42a5f5;
      font-size: 0.95rem;
      padding-left: 12px;
      margin-bottom: 20px;
    }

    .state-display {
      font-size: 16px;
      margin: 12px 0;
      background-color: #f4faff;
      padding: 10px 12px;
      border-radius: 6px;
      border-left: 4px solid #42a5f5;
    }

    .done-button {
      font-size: 14px;
      padding: 10px 18px;
      border: none;
      border-radius: 6px;
      background-color: #42a5f5;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .done-button:hover { background-color: #1e88e5; }

    .center { text-align: center; }

    /* Intro, instructions, error, end screens */
    #intro-screen, #instructions-screen, #end-screen {
      max-width: 600px;
      background-color: #ffffff;
      padding: 24px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      display: none;
    }

    #end-screen { text-align: center; }

    #error-message {
      display: none;
      max-width: 600px;
      color: #B00020;
      background-color: #ffe6e6;
      padding: 12px 16px;
      margin-bottom: 20px;
      border-radius: 8px;
      text-align: center;
      border: 1px solid #F44336;
    }



  </style>
</head>
<body>

  <!-- Inline error message (replaces native alerts) -->
  <div id="error-message"></div>

  <!-- Container for transient voice prompt banner (inserted dynamically) -->
  <!-- <div id="prompt-message"></div> created by ensurePromptBanner() -->

  <!-- Container for the multi-step intro screens -->
  <div id="intro-screen"></div>

  <!-- Container for per-block instructions -->
  <div id="instructions-screen"></div>

  <!-- The main task UI (blank left/right columns during trials) -->
  <div id="task-ui" class="container" style="display: none;"></div>

  <!-- The final end screen -->
  <div id="end-screen">
    <p style="margin-bottom: 24px; font-size: 18px;">
      The study is now complete.<br>
      Press any key to receive payment.
    </p>
  </div>

  <script type="module">
    // --------------------------------------
    // GLOBAL CONFIG
    // --------------------------------------
    const N = 9; // N problems per block

    // Randomly sample starting states
    function getRandomIndices(len, exclude = [], count = 5) {
      const idxs = [];
      while (idxs.length < count) {
        const i = Math.floor(Math.random() * len);
        if (!idxs.includes(i) && !exclude.includes(i)) idxs.push(i);
      }
      return idxs;
    }

    const moveBlock = Array.from({ length: N }, () => ({}));
    const changeBlock = Array.from({ length: N }, () => ({}));

    // Decide order of blocks randomly
    const blocks = Math.random() < 0.5 ? ['move','change'] : ['change','move'];
    const blockData = { move: moveBlock, change: changeBlock };

    let blockIndex = 0; // which block (0 or 1)
    let trialIndex = 0; // which trial (0..N-1)

    // Build per-block random prompts (N per block) from the correct stimulus set
    const movePrompts   = buildPromptsWithConstraints(GT_STIMULI_B1, N);
    const changePrompts = buildPromptsWithConstraints(GT_STIMULI_B2, N);
    let currentPrompt = null;
    const promptData = { move: movePrompts, change: changePrompts };

    // puzzle state and logs
    let currentState = {};
    let allProblemLogs = [];


    // participant info
    let participantData = { agreement:'', gender:'', age:'', languages:'', languageDetails:'' };

    // problem start timestamp
    let problemStartTime = null;


    // --------------------------------------
    // FIREBASE CONFIGURATION
    // --------------------------------------
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getFirestore, collection, addDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
    import { getStorage, ref, uploadBytes } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

    const firebaseConfig = {
      apiKey: "AIzaSyCUc55f4nUPyN6MoZX8Qydia3Ouibj8BD0",
      authDomain: "graph-traversal-human-data.firebaseapp.com",
      projectId: "graph-traversal-human-data",
      storageBucket: "graph-traversal-human-data.firebasestorage.app",
      messagingSenderId: "768052117663",
      appId: "1:768052117663:web:fdbd4874cd9fe10cb8e2aa",
      measurementId: "G-ZR2Y25S648"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const storage = getStorage(app);
  
    // --------------------------------------
    // HELPERS
    // --------------------------------------

    function showError(msg) {
      const err = document.getElementById('error-message');
      err.textContent = msg;
      err.style.display = 'block';
      setTimeout(() => err.style.display = 'none', 3000);
    }

    // Build a prompt list with constraints… 
    function buildPromptsWithConstraints(stimuli, N) {
      // Shuffle a working copy
      const pool = stimuli.slice();
      for (let i = pool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }

      // Bucket by path_nodes length
      const bySize = { 3: [], 4: [], 5: [] };
      pool.forEach(s => {
        const n = s?.path_nodes?.length;
        if (bySize[n]) bySize[n].push(s);
      });

      const out = [];

      const removeFrom = (size, stim) => {
        const arr = bySize[size];
        if (!arr) return;
        const idx = arr.indexOf(stim);
        if (idx > -1) arr.splice(idx, 1);
      };

      const takeOneFromSizes = (sizes) => {
        const bag = [];
        sizes.forEach(sz => { if (bySize[sz]?.length) bag.push(...bySize[sz]); });
        if (!bag.length) return null;
        const chosen = bag[Math.floor(Math.random() * bag.length)];
        removeFrom(chosen.path_nodes.length, chosen);
        return chosen;
      };

      // 1) First trial must have 3 path_nodes
      let pick = takeOneFromSizes([3]);
      if (!pick) { console.warn("No 3-node for first trial; relaxing."); pick = takeOneFromSizes([4, 5]); }
      if (pick) out.push(pick);

      // 2) Second trial must have 3 or 4 path_nodes
      pick = takeOneFromSizes([3, 4]);
      if (!pick) { console.warn("No 3/4-node for second trial; relaxing."); pick = takeOneFromSizes([5]); }
      if (pick) out.push(pick);

      // 3) While filling the rest, enforce:
      //    - No two consecutive 5sflan
      //    - If sequence is 4-5 or 5-4, next must be 3
      while (out.length < Math.min(N, stimuli.length)) {
        const prev = out[out.length - 2]?.path_nodes?.length ?? null;
        const last = out[out.length - 1]?.path_nodes?.length ?? null;

        // Rule: if we have 4-5 or 5-4, next must be 3 (hard try)
        const forceNextIs3 = (prev === 4 && last === 5) || (prev === 5 && last === 4);

        pick = null;

        if (forceNextIs3) {
          pick = takeOneFromSizes([3]);
          if (!pick) {
            console.warn("No 3-node available after a 4-5/5-4 sequence; relaxing to other allowed sizes.");
          }
        }

        if (!pick) {
          // Start with all sizes
          let allowed = [3, 4, 5];

          // 3) No two consecutive 5s
          if (last === 5) allowed = allowed.filter(s => s !== 5);

          // Try to pick from allowed
          pick = takeOneFromSizes(allowed);

          // Final relax if pool is tight
          if (!pick) pick = takeOneFromSizes([3, 4, 5]);
          if (!pick) break;
        }

        out.push(pick);
      }

      return out.slice(0, N);
    }



    // ---- Trial timer (limit based on cities) ----
    let countdownInterval = null;
    let countdownDeadline = 0;
    let trialActive = false; // guards against double-ending

    function formatClock(ms) {
      const total = Math.ceil(ms / 1000);
      const m = Math.max(0, Math.floor(total / 60));
      const s = Math.max(0, total % 60);
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function updateTimerDisplay() {
      const remaining = Math.max(0, countdownDeadline - Date.now());
      const secs = Math.ceil(remaining / 1000);

      // Shared logic
      const updateEl = (el) => {
        if (!el) return;
        el.textContent = formatClock(remaining);
        el.classList.toggle('urgent',  secs <= URGENT_THRESHOLD_S);
        el.classList.toggle('warning', secs > URGENT_THRESHOLD_S && secs <= WARNING_THRESHOLD_S);
      };

      updateEl(document.getElementById('trial-timer'));
      updateEl(document.getElementById('pre-final-timer'));

      if (remaining <= 0) {
        clearTrialTimer();

        // If we're on the PreFinalSurvey, auto-advance instead of ending a trial
        if (document.getElementById('pre-final-survey')) {
          showFinalSurvey();
        } else {
          endTrial('timeout');
        }
      }
    }

    function getTrialLimitMsFromCities(count) {
      const secsByCities = { 3: 90, 4: 150, 5: 210 }; // seconds
      const seconds = secsByCities[count] ?? 15;
      return seconds * 1000;
    }

    function startTrialTimer(limitMs) {
      if (typeof limitMs !== 'number') throw new Error('startTrialTimer requires limitMs');
      clearTrialTimer();
      countdownDeadline = Date.now() + limitMs;

      const el = document.getElementById('trial-timer');
      if (el) el.classList.remove('urgent', 'warning');

      updateTimerDisplay();
      countdownInterval = setInterval(updateTimerDisplay, 250);
    }

    const WARNING_THRESHOLD_S = 20;
    const URGENT_THRESHOLD_S  = 10;

    // Append-only textareas: allow only additions at the end.
    // Blocks Backspace/Delete, Cut, Undo/Redo deletions, mid-text edits, and
    // forces Paste/typing to append to the end.
    function makeAppendOnly(el) {
      if (!el) return;

      const toEnd = () => {
        const len = el.value.length;
        el.selectionStart = el.selectionEnd = len;
      };

      let last = el.value;

      // Hard block obvious delete keys and cut/undo
      el.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (k === 'backspace' || k === 'delete') e.preventDefault();
        if ((e.ctrlKey || e.metaKey) && (k === 'z' || k === 'x')) e.preventDefault(); // undo/cut
      });

      el.addEventListener('cut', (e) => e.preventDefault());

      // Make paste append-only
      el.addEventListener('paste', (e) => {
        e.preventDefault();
        const text = (e.clipboardData || window.clipboardData).getData('text') || '';
        el.value += text;
        last = el.value;
        toEnd();
      });

      // Fine-grained control of edits (covers mobile, IME, etc.)
      el.addEventListener('beforeinput', (e) => {
        const t = e.inputType || '';
        const isDeletion = t.startsWith('delete') || t === 'historyUndo' || t === 'historyRedo';
        const atEnd = el.selectionStart === el.value.length && el.selectionEnd === el.value.length;

        if (isDeletion) {
          e.preventDefault();
          toEnd();
          return;
        }

        // If user tries to type/insert in the middle, append instead
        if (!atEnd && t.startsWith('insert')) {
          e.preventDefault();
          // e.data is present for typing; paste handled above
          if (typeof e.data === 'string') {
            el.value += e.data;
            last = el.value;
            toEnd();
          }
        }
      });

      // Fallback guard: if length ever shrinks, restore last value
      el.addEventListener('input', () => {
        if (el.value.length < last.length) {
          el.value = last;
        } else {
          last = el.value;
        }
        toEnd();
      });

      // Keep caret pinned to end for clicks/focus
      el.addEventListener('focus', toEnd);
      el.addEventListener('click', toEnd);
    }


    function clearTrialTimer() {
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }

    function showPreFinalSurvey() {
      addPreFinalSurveyStyles();

      const mount = document.getElementById('instructions-screen');
      mount.style.display = 'block';
      mount.classList.add('wide');
      document.getElementById('task-ui').style.display = 'none';

      // Anchor page content to the top while the pre-final survey is showing
      document.body.classList.add('pre-final-scroll');
      ensureStyle('pre-final-internal-scroll-css', `
        /* Let the instructions/survey panel scroll if it's taller than the viewport */
        #instructions-screen.wide {
          max-height: calc(100vh - 100px);
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }

        /* Keep the timer visible while the user scrolls the survey */
        #pre-final-timer { position: sticky; top: 8px; }
      `);


      // ✅ Your custom text
      const questions = ['When I navigate, I pay attention to the landmarks at the turning points and try to remember their sequence.', 
      'I have navigational intuition.', "I can easily point to a specific place outside the building when I don't see it from the inside.", 
      'I can find my way under low visibility conditions (or even in darkness) in familiar places better than other people', 
      'I rely primarily on a schematic mental representation of my environment to figure out my position in the environment.', 
      'My mental representation of the route that I traversed is analogous to a schematic map (e.g., floor-plan, blue-print, metro map) rather than a first-person perspective of routes and landmarks.', 
      'To avoid getting lost, I usually try to memorize the landmarks around me, along with their associated turns.', 'I have an “internal compass”', 
      'I usually attempt to mentally represent route segments, turns and their spatial relationships from a topdown aerial perspective.', 
      'I usually attempt to visualize a map of the environment from a top-down aerial perspective as I travel.', 
      'At any time during a route, I can point back to the landmarks I have passed by.', 
      'I rely primarily on a schematic mental representation of my environment to help me in finding shortcuts.', 
      'I can plan out my route of travel by visualizing a schematic map from a top-down aerial perspective.', 
      'To reach my destination, I largely recruit a set of procedures telling me the actions to perform (i.e., go straight/back, turn left/right) at different locations on my route.', 
      'I rely primarily on landmarks as signs of turning points along my route of travel.', 'I keep a mental record of the landmarks I see on my traveling route in a sequential fashion.', 
      'If I were to walk on my route again, I would depend heavily on a sequence of mental “snapshots” of landmarks or scenes to go to the places I had been to.', 
      'In an unfamiliar environment with no clear landmarks (e.g., forest, desert, new city) and/or in low visibility conditions (e.g., fog, heavy rain), I still have a good sense of where I am heading.'];

      const leftQs = questions.slice(0, 9);  // Q1–Q5
      const rightQs = questions.slice(9);    // Q6–Q10

      const colHtml = (labels, colId, startIndex) => `
        <div class="survey-col" id="${colId}">
          ${labels.map((label, idx) =>
            likertRowHtml(`${colId}-${startIndex + idx + 1}`,
              `${startIndex + idx + 1}. ${label}`)
          ).join('')}
        </div>
      `;

      mount.innerHTML = `
        <style>
          .survey-title {
            font-size: 20px; /* adjust size as you like */
          }
        </style>
        <style>
          .survey-subtitle {
            font-size: 16px; /* adjust size as you like */
          }
        </style>
        <div id="pre-final-timer" class="trial-timer" aria-live="polite"></div>
        <div id="pre-final-survey" class="survey-container">
          <h2 class="survey-title">Navigation Survey</h2>
          <h3 class="survey-subtitle">Respond based on how you navigate the familiar places in your everyday environment (Scroll to view all questions).</h3>
          <div class="survey-grid">
            ${colHtml(leftQs, 'col1', 0)}   <!-- 1–5 -->
            ${colHtml(rightQs, 'col2', 9)}  <!-- 6–10 -->
          </div>

          <div class="survey-key">
            <strong>Scale:</strong>
            1 (Totally Disagree) · 2 (Somewhat Disagree) · 3 (Neutral) · 
            4 (Somewhat Agree) · 5 (Totally Agree)
          </div>

          <div class="survey-actions">
            <button id="survey-submit" disabled>Continue</button>
          </div>
        </div>
      `;

      const responses = {};
      const submitBtn = document.getElementById('survey-submit');
      const allButtons = mount.querySelectorAll('#pre-final-survey .likert-btn');

      function updateSubmitState() {
        submitBtn.disabled = Object.keys(responses).length < 10;
      }

      allButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const row = btn.closest('.q-row');
          const qid = row.dataset.qid;
          row.querySelectorAll('.likert-btn').forEach((b) => {
            b.setAttribute('aria-pressed', 'false');
            b.classList.remove('selected');
          });
          btn.setAttribute('aria-pressed', 'true');
          btn.classList.add('selected');
          responses[qid] = Number(btn.dataset.val);
          updateSubmitState();
        });
      });

      startTrialTimer(7 * 60 * 1000);

      submitBtn.addEventListener('click', async () => {
        window.preFinalSurvey = { responses: { ...responses }, completedAt: Date.now() };
        showFinalSurvey();
      });
    }

    function showFinalSurvey() {
      addFinalSurveyStyles();

      const mount = document.getElementById('instructions-screen');
      mount.style.display = 'block';
      mount.classList.add('wide');
      document.getElementById('task-ui').style.display = 'none';

      const questions = [
        { id: 'q1', text: 'How accurately and completely did your thinking aloud reflect your true thought processes throughout the experiment?', scale: '1 (Very inaccurately) · 2 (Somewhat inaccurately) · 3 (Neutral) · 4 (Somewhat accurately) · 5 (Very accurately)' },
        { id: 'q2', text: 'How familiar are you with graph theory and algorithms such as breadth-first search (BFS) or depth-first search (DFS)?', scale: '1 (Not at all familiar) · 2 (Slightly familiar) · 3 (Moderately familiar) · 4 (Very familiar) · 5 (Extremely familiar)' }
      ];

      const renderBlock = (q, idx, withTextbox) => `
        <section class="question-block">
          ${likertRowHtml(q.id, `${idx + 1}. ${q.text}`)}
          ${withTextbox ? `<textarea id="${q.id}-text" class="survey-text" placeholder="Provide details here…" style="resize:none"></textarea>` : ``}
          <div class="survey-key"><strong>Scale:</strong> ${q.scale}</div>
        </section>
      `;

      mount.innerHTML = `
        <div id="final-survey" class="survey-container">
          <h2 class="survey-title">Final Survey</h2>
          <div class="survey-grid">
            <div class="survey-col" id="col-single">
              ${renderBlock(questions[0], 0, true)}
              ${renderBlock(questions[1], 1, false)}
            </div>
          </div>
          <div class="survey-actions">
            <button id="survey-submit" disabled>Submit</button>
          </div>
        </div>
      `;

      const responses = {};
      const submitBtn = document.getElementById('survey-submit');
      const allButtons = mount.querySelectorAll('#final-survey .likert-btn');

      function updateSubmitState() {
        submitBtn.disabled = Object.keys(responses).length < 2; // only Likert responses required
      }

      allButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const row = btn.closest('.q-row');
          const qid = row.dataset.qid;
          row.querySelectorAll('.likert-btn').forEach((b) => {
            b.setAttribute('aria-pressed', 'false');
            b.classList.remove('selected');
          });
          btn.setAttribute('aria-pressed', 'true');
          btn.classList.add('selected');
          responses[qid] = Number(btn.dataset.val);
          updateSubmitState();
        });
      });

      submitBtn.addEventListener('click', async () => {
        const freeText = {
          q1: (document.getElementById('q1-text')?.value || '').trim()
        };

        window.finalSurvey = {
          responses: { ...responses },
          freeText,
          completedAt: Date.now()
        };
        finishStudy();
      });
    }

    // ===== helpers =====
    function likertRowHtml(qId, label) {
      return `
        <div class="q-row" data-qid="${qId}">
          <div class="q-text">${label}</div>
          <div class="likert" role="radiogroup" aria-label="${label}">
            ${[1,2,3,4,5].map(v => `
              <button type="button"
                      class="likert-btn"
                      data-val="${v}"
                      aria-pressed="false">${v}</button>
            `).join('')}
          </div>
        </div>
      `;
    }

    // ---- style helpers ----
    function ensureStyle(id, css) {
      let el = document.getElementById(id);
      if (!el) {
        el = document.createElement('style');
        el.id = id;
        el.textContent = css;
        document.head.appendChild(el);
      }
    }
    function removeStyle(id) {
      const el = document.getElementById(id);
      if (el) el.remove();
    }

    // Shared rules for both surveys (keep this small & generic)
    function addBaseSurveyStyles() {
      ensureStyle('survey-base-css', `
        .survey-container { max-width: 1000px; margin: 0 auto; padding: 16px; }
        .survey-title { text-align: center; margin-bottom: 16px; }
        .survey-subtitle { text-align: center }
        .survey-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; align-items: start; }
        .survey-col { display: grid; gap: 8px; }
        .q-row {
          display: grid;
          grid-template-columns: 1.2fr 1fr; /* left question / right controls */
          gap: 12px; align-items: center; padding: 8px 10px;
          border: 1px solid #ddd; border-radius: 8px; background: #fafafa;
        }
        .q-text { font-size: 14px; line-height: 1.3; }
        .likert { display: flex; justify-content: space-between; gap: 6px; }
        .likert-btn {
          min-width: 36px; min-height: 32px; border: 1px solid #bbb; border-radius: 6px;
          background: white; cursor: pointer; font-size: 14px;
        }
        .likert-btn.selected, .likert-btn[aria-pressed="true"] {
          outline: none; border-color: #222; background: #eaeaea; font-weight: 600;
        }
        .survey-key { text-align: center; margin: 20px 0 10px; font-size: 14px; }
        .survey-actions { display: flex; justify-content: center; margin-top: 8px; }
        #survey-submit[disabled] { opacity: .6; cursor: not-allowed; }

        #instructions-screen.wide { max-width: 1100px; width: min(1100px, 95vw); }

        /* shared width rules for textareas used in both screens */
        #final-survey .survey-col textarea.survey-text,
        #pre-final-survey textarea.survey-text,
        .notes-textarea,
        .practice-textarea {
          width: 100%; max-width: none; min-width: 0; box-sizing: border-box;
        }
      `);
    }

    // Pre-final survey only 
    function addPreFinalSurveyStyles() {
      addBaseSurveyStyles();
      removeStyle('final-survey-css'); // keep head lean when switching
      ensureStyle('pre-final-survey-css', `
        /* keep the survey centered and prevent overflow */
        #pre-final-survey.survey-container { max-width: 1100px; width: 100%; margin: 0 auto; }
        #pre-final-survey .survey-grid { grid-template-columns: minmax(0,1fr) minmax(0,1fr); }
        #pre-final-survey .survey-col,
        #pre-final-survey .q-row,
        #pre-final-survey .q-row > * { min-width: 0; }

        /* tighter Likert buttons */
        #pre-final-survey .likert { width: max-content; justify-content: flex-start; gap: 4px; flex-wrap: nowrap; }
        #pre-final-survey .likert-btn { 
          flex: 0 0 auto; min-width: 26px; height: 26px; padding: 0 6px;
          font-size: 12px; line-height: 26px; border-radius: 4px; margin: 0; 
        }

        /* base split: left question, right buttons */
        #pre-final-survey .q-row {
          grid-template-columns: 1fr auto; /* auto shrinks right col to fit buttons */
          gap: 8px; /* smaller gap between question text and buttons */
        }

        /* override when a textarea is present */
        #pre-final-survey .q-row:has(textarea.survey-text) {
          grid-template-columns: 1.2fr auto;
        }
      `);
    }

    // Final survey only
    function addFinalSurveyStyles() {
      addBaseSurveyStyles();
      removeStyle('pre-final-survey-css'); // keep head lean when switching
      ensureStyle('final-survey-css', `
        /* Center and single-column layout */
        #final-survey .survey-grid { grid-template-columns: 1fr; justify-items: center; }
        #final-survey .survey-col { width: min(820px, 95vw); max-width: 820px; margin: 0 auto; }
        #final-survey .survey-actions { justify-content: center; }

        /* Stack question over controls and center */
        #final-survey .q-row { grid-template-columns: 1fr; text-align: center; }
        #final-survey .likert { justify-content: center; gap: 10px; }
        #final-survey .survey-key { text-align: center; }

        /* Centered, fixed-width textarea */
        #final-survey textarea.survey-text {
          display: block; margin: 8px auto 12px; width: 100%; box-sizing: border-box;
          resize: none !important; overflow: auto;
        }
      `);
    }




    // --------------------------------------
    // AUDIO RECORDING
    // --------------------------------------
    let audioStream = null;
    let recorder = null;
    const audioChunks = []; // {block, trial, blob}

    async function requestAudioPermission() {
      try {
        audioStream = await navigator.mediaDevices.getUserMedia({ audio:true });
      } catch (e) {
        console.error(e);
        showError("Microphone access is needed to record your responses.");
      }
    }

    function startRecording(blockNum, trialNum) {
      if (!audioStream) return;
      recorder = new MediaRecorder(audioStream);
      recorder.ondataavailable = e => {
        if (e.data.size > 0) audioChunks.push({ block:blockNum, trial:trialNum, blob:e.data });
      };
      recorder.start();
    }

    function stopRecording(cb) {
      if (!recorder) { cb && cb(); return; }
      recorder.onstop = () => { cb && cb(); };
      recorder.stop();
      recorder = null;
    }

    // =============================
    // LIVE VOICE FEEDBACK MODULE
    function ensurePromptBanner() {
      let el = document.getElementById("prompt-message");
      if (!el) {
        el = document.createElement("div");
        el.id = "prompt-message";
        el.style.display = "none";
        el.style.maxWidth = "600px";
        el.style.margin = "0 0 20px 0";
        el.style.background = "#E3F2FD";
        el.style.color = "#0D47A1";
        el.style.border = "1px solid #90CAF9";
        el.style.borderRadius = "8px";
        el.style.padding = "12px 16px";
        el.style.textAlign = "center";
        const anchor = document.querySelector('#error-message');
        (anchor?.parentNode || document.body).insertBefore(el, anchor?.nextSibling || null);
      }
      return el;
    }

    function showPrompt(msg, ms = 4000) {
      const el = ensurePromptBanner();
      el.textContent = msg;
      el.style.display = "block";
      clearTimeout(showPrompt._t);
      showPrompt._t = setTimeout(() => (el.style.display = "none"), ms);
    }

    const VoiceFeedback = (() => {
      let ctx = null;
      let source = null;
      let analyser = null;
      let freqData = null;
      let running = false;
      let timer = null;

      const cfg = {
        intervalSec: 20,
        threshold: .0008,
        minHz: 85,
        maxHz: 255,
        fftSize: 2048,
        smoothing: 0.8,
      };

      let accum = 0;
      let frames = 0;
      let minBin = 0, maxBin = 0;

      function setupBins(sampleRate, fftSize) {
        const binHz = sampleRate / fftSize;
        minBin = Math.floor(cfg.minHz / binHz);
        maxBin = Math.ceil(cfg.maxHz / binHz);
      }

      function sampleLoop() {
        if (!running) return;
        analyser.getFloatFrequencyData(freqData);
        let total = 0;
        for (let i = minBin; i <= maxBin && i < freqData.length; i++) {
          total += Math.pow(10, freqData[i] / 20);
        }
        const avg = total / Math.max(1, (maxBin - minBin + 1));
        accum += avg;
        frames += 1;
        requestAnimationFrame(sampleLoop);
      }

      async function start() {
        if (running) return;
        if (!audioStream) return;
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        await ctx.resume().catch(()=>{});
        source = ctx.createMediaStreamSource(audioStream);

        analyser = ctx.createAnalyser();
        analyser.fftSize = cfg.fftSize;
        analyser.smoothingTimeConstant = cfg.smoothing;

        freqData = new Float32Array(analyser.frequencyBinCount);
        source.connect(analyser);

        setupBins(ctx.sampleRate, analyser.fftSize);
        accum = 0; frames = 0; running = true;
        sampleLoop();

        timer = setInterval(() => {
          if (!running) return;
          const avgActivity = frames ? (accum / frames) : 0;
          if (avgActivity < cfg.threshold) {
            showPrompt("Please keep speaking your thoughts aloud.");
          }
          console.debug('avgActivity', avgActivity.toFixed(5));
          accum = 0; frames = 0;
        }, cfg.intervalSec * 1000);
      }

      async function stop() {
        running = false;
        clearInterval(timer);
        try { source && source.disconnect(); } catch (_) {}
        try { ctx && (await ctx.close()); } catch (_) {}
        ctx = source = analyser = null;
        freqData = null;
        accum = 0; frames = 0;
      }

      function setConfig(overrides) { Object.assign(cfg, overrides || {}); }
      return { start, stop, setConfig, cfg };
    })();


    // --------------------------------------
    // INTRO SCREENS
    // --------------------------------------
    let introIndex = 0;
    const introScreens = [
      // 0
      `
        <p>In this study, you will solve problems involving identifying the shortest path between cities or people.</p>
        <p>Only anonymous data without any personal information will be stored for research purposes.</p>
        <p>Audio will also be recorded while you solve the problems.</p>
        <p>The whole study will take no longer than 1 hour to complete.</p>
        <p>If you agree to participate in the study, please respond by typing something in the box provided below.</p>
        <p>Otherwise, please close the study window.</p>
        <p><input type="text" id="agreeInput" style="width: 95%;" placeholder="Type your response here..."></p>
      `,
      // 1
      `        <p>Please provide the following information.</p>
        <p>Gender:</p>
        <p>
          <select id="genderSelect" style="width: 100%;">
            <option value="" disabled selected hidden>Select...</option>
            <option value="Male">Male</option>
            <option value="Female">Female</option>
            <option value="Nonbinary">Nonbinary</option>
            <option value="Other">Other (please specify)</option>
          </select>
        </p>
        <p id="otherGenderWrapper" style="display:none;">
          <input type="text" id="otherGenderInput" style="width: 95%;" placeholder="Please specify..." />
        </p>
        <p>Age:</p>
        <p><input type="number" id="ageInput" style="width: 95%;" placeholder="Type your age here..." /></p>

        <p>Language(s) Spoken:</p>
        <p>
          <select id="languageSelect" style="width: 100%;">
            <option value="" disabled selected hidden>Select...</option>
            <option value="Monolingual">Monolingual (English only)</option>
            <option value="Bilingual">Bilingual</option>
            <option value="Multilingual">Multilingual (more than 2 languages)</option>
          </select>
        </p>
        <p id="languageDetailsWrapper" style="display:none;">
          <label for="languageDetailsInput" style="display:block; margin-bottom:4px;">
            Please list the language(s) besides English you speak, and briefly include your level of fluency.
          </label>
          <textarea id="languageDetailsInput" style="width: 95%; min-height: 70px;" placeholder="e.g., Spanish (fluent), Mandarin (intermediate)"></textarea>
        </p>
    `,
      // 2
      `
        <p>Please turn off any music or potential sources of distraction.</p>
        <p>The experiment will switch to full screen mode when you press the button below.</p>
        <p>Please remain in full screen mode until the experiment is complete.</p>
        <p>Microphone access will also be requested for audio recording.</p>
      `,
      // 3
      `
        <p>The experiment will consist of two blocks of problems where you identify the shortest path between fictional cities or people. Each block will contain ${N} problems.</p>
        <p>Before the first block, you will be presented with instructions.</p>
        <p>You will have a brief period to rest in between the first and second blocks.</p>
        <p>Please press 'Next' to see the instructions for Block #1.</p>
      `
    ];

    function startIntro() {
      introIndex = 0;
      showIntroScreen();
    }

    function showIntroScreen() {
      const introDiv = document.getElementById('intro-screen');
      introDiv.innerHTML = introScreens[introIndex] + `
        <div style="text-align: center; margin-top: 24px;">
          <button id="introNextBtn" style="padding: 10px 20px;">Next</button>
        </div>
      `;
      introDiv.style.display = 'block';

      document.getElementById('introNextBtn').addEventListener('click', handleIntroNext);

      if (introIndex === 1) {
        const sel = document.getElementById('genderSelect');
        sel.addEventListener('change', () => {
          document.getElementById('otherGenderWrapper').style.display =
            sel.value === 'Other' ? 'block' : 'none';
        });

        const langSel = document.getElementById('languageSelect');
        const langWrap = document.getElementById('languageDetailsWrapper');
        if (langSel && langWrap) {
          langSel.addEventListener('change', () => {
            const show = langSel.value === 'Bilingual' || langSel.value === 'Multilingual';
            langWrap.style.display = show ? 'block' : 'none';
          });
        }
      }
    }

    async function handleIntroNext() {
      if (introIndex === 0) {
        const val = document.getElementById('agreeInput').value.trim();
        if (!val) { showError("Please type something to proceed."); return; }
        participantData.agreement = val;
        } else if (introIndex === 1) {
        const gSel = document.getElementById('genderSelect');
        const age = document.getElementById('ageInput').value.trim();
        const langSel = document.getElementById('languageSelect');
        const langDetails = (document.getElementById('languageDetailsInput')?.value || '').trim();

        if (!gSel.value || !age || !langSel.value) {
          showError("Please select a gender, enter your age, and choose your languages."); return;
        }

        if (gSel.value === 'Other') {
          const spec = document.getElementById('otherGenderInput').value.trim();
          if (!spec) { showError("Please specify your gender."); return; }
          participantData.gender = spec;
        } else {
          participantData.gender = gSel.value;
        }
        participantData.age = age;

        if ((langSel.value === 'Bilingual' || langSel.value === 'Multilingual') && !langDetails) {
          showError("Please list the other language(s) you speak (besides English) and your fluency."); return;
        }
        participantData.languages = langSel.value;
        participantData.languageDetails = langDetails;

      } else if (introIndex === 2) {
        if (document.body.requestFullscreen) document.body.requestFullscreen();
        else if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
        await requestAudioPermission();
      }

      introIndex++;
      if (introIndex < introScreens.length) {
        showIntroScreen();
      } else {
        document.getElementById('intro-screen').style.display = 'none';
        loadBlock();
      }
    }

    // --------------------------------------
    // PER-BLOCK INSTRUCTIONS
    // --------------------------------------
    function loadBlock() {
      // NEW (order-based)
      const blockType = blocks[blockIndex];
      const blockNum  = blockIndex + 1;

      // first block gets Move instructions; second gets Change
      (blockIndex === 0 ? showMoveInstructions : showChangeInstructions)(blockNum);
    }

    function showMoveInstructions(blockNumber) {
      const inst = document.getElementById('instructions-screen');
      inst.style.display = 'block';
      inst.innerHTML = `
        <h2>Experiment Instructions (for both blocks)</h2>
        <p>In this experiment, you will be presented with sets of cities or people and their connections. Your goal is to find the shortest path between two fictional cities or people given the specified layout</p>
        <p style="font-size:1.15rem;"><strong>Importantly, as you are solving the problems, try to say out loud everything that goes through your mind.</strong></p>
        <p style="font-size:1.15rem;"><strong>If you are silent for a long period of time, we will send you a reminder to speak your thoughts aloud.</strong></p>
        <p>There will be ${N} problems in each block.</p>
        <div style="text-align:center;margin-top:24px;">
          <button id="begin-block-btn" style="padding:10px 20px;">Continue to Practice Trial</button>
        </div>
      `;
      document.getElementById('begin-block-btn').addEventListener('click', () => {
        showMoveRuleCheck(blockNumber);
      });
    }

    // Rule check (simplified right column: only Continue)
    function showMoveRuleCheck(blockNumber) {
      const inst = document.getElementById('instructions-screen');
      inst.style.display = 'none';

      const container = document.getElementById('task-ui');
      container.style.display = 'flex';

      // Left-column practice text + example distance table
      const leftHTML = `
        <div class="rules-text">
          <h3>Example Trial (Practice)</h3>
          <h3>Instructions</h3>
          <p>In this experiment, each problem will present a set of fictional cities or people and their connections. When the same city or person's name appears more than once in the problem, it refers to the same city or person. Your goal is to find the shortest path between two cities or people given the specified layout.</p>
          <p><strong>Task:</strong></p>
          <p>Consider the following list of social relations: Lily knows about Josh, Mila knows about Miles, Miles knows about Ben, Miles knows about Gabe, Lily knows about Adam, Mila knows about Lily. What is the shortest path from Mila to Ben?</p>
          <p><strong>Importantly, as you are solving the problems, try to say out loud everything that goes through your mind.</strong></p>
          <p>Feel free to take notes as you solve the problems, and include your Final Response as a list of names separated by commas. You will not be able to delete what you type.</p>
          <p>Once you feel comfortable with the format and have typed in a Final Response, press <strong>Continue</strong> to begin the experiment.</p>
        </div>
      `;


      container.innerHTML = `
        <div class="left-column">${leftHTML}</div>
        <div class="right-column" style="justify-content:flex-start;">
          <label for="practice-notes" style="margin-top:12px; display:block;">Notes:</label>
          <textarea id="practice-notes"
            aria-label="Practice typing area"
            placeholder="Type your notes here…"
            class="practice-textarea"></textarea>

          <label for="practice-final-response" style="margin-top:12px; display:block;">Final Response:</label>
          <textarea id="practice-final-response"
            aria-label="Final response area"
            placeholder="Type your final response here…"
            class="practice-textarea"
            style="margin-top:6px; min-height:80px;"></textarea>
          <div class="center" style="margin-top:12px;">
            <button id="move-check-continue-btn" class="done-button">Continue (Begin Experiment)</button>
          </div>
        </div>
      `;

      makeAppendOnly(document.getElementById('practice-notes'));
      makeAppendOnly(document.getElementById('practice-final-response'));

      const continueBtn = container.querySelector('#move-check-continue-btn');
      const finalTA = document.getElementById('practice-final-response');

      function updatePracticeGate() {
        const ok = (finalTA.value || '').trim().length > 0;
        continueBtn.disabled = !ok;
        continueBtn.setAttribute('aria-disabled', String(!ok));
      }
      updatePracticeGate();
      finalTA.addEventListener('input', updatePracticeGate);

      continueBtn.addEventListener('click', () => {
        if (continueBtn.disabled) return; // defense-in-depth
        participantData.practiceNotes = (document.getElementById('practice-notes')?.value || '').trim();
        startBlock();
      });
  }


    function showChangeInstructions(blockNumber) {
      const inst = document.getElementById('instructions-screen');
      inst.style.display = 'block';
      inst.innerHTML = `
        <h2>Please take a brief rest before continuing to Block #${blockNumber}</h2>
        <p>In this block, you will continue solving shortest-path style problems.</p>
        <p>As you solve the problems, please continue to describe your thought process out loud.</p>
        <p>There will be ${N} problems in this block.</p>
        <div style="text-align:center;margin-top:24px;">
          <button id="begin-block-btn" style="padding:10px 20px;">Begin block</button>
        </div>
      `;
      document.getElementById('begin-block-btn').addEventListener('click', () => {
        inst.style.display = 'none';
        startBlock();
      });
    }

    // --------------------------------------
    // BLOCK & TRIAL FLOW
    // --------------------------------------
    function startBlock() {
      trialIndex = 0;
      document.getElementById('task-ui').style.display = 'flex';
      loadTrial();
    }


    function loadTrial() {
      const blockNum = blockIndex + 1;
      const problemNum = trialIndex + 1;
      const type = blocks[blockIndex];
      currentPrompt = (type === 'move' ? movePrompts : changePrompts)[trialIndex];
      currentState = structuredClone(blockData[type][trialIndex]);
      problemStartTime = Date.now();
      startRecording(blockNum, problemNum);
      VoiceFeedback.start();
      const numCities = (currentPrompt?.path_nodes || []).length;
      const limitMs   = getTrialLimitMsFromCities(numCities);
      renderUI(type, limitMs);
      trialActive = true;
      startTrialTimer(limitMs);  // timer runs invisibly; still enforces time limit
    }

    // --------------------------------------
    // RENDERING — MOVE/CHANGE BLOCKS
    // --------------------------------------
    function renderUI(type, limitMs) {
      const container = document.getElementById('task-ui');

      // Left column = instructions + problem prompt

      const instructionsHTML = `
        <div class="rules-text">
          <h3>Instructions</h3>
          <p>Your goal is to find the shortest path between two cities or people given the specified layout. When the same city or person's name appears more than once in the problem, it refers to the same city or person.</p>
          <p><strong>Task:</strong></p>
        </div>
        <div id="problem-prompt" class="stim-prompt">
          ${currentPrompt?.prompt || ''}
        </div>
        <p><strong>Importantly, as you are solving the problem, try to say out loud everything that goes through your mind.</strong></p>
        <p>Feel free to take notes as you solve the problem, and include your Final Response as a list of cities or names separated by commas. You will not be able to delete what you type.</p>
      `;

      const cities = currentPrompt?.path_nodes || ['City 1','City 2','City 3','City 4','City 5'];

      container.innerHTML = `
        <div class="left-column">${instructionsHTML}</div>
        <div class="right-column" style="justify-content:flex-start;">

          <div id="trial-timer" class="trial-timer" aria-live="polite">${formatClock(limitMs)}</div>
          <label for="trial-notes" style="margin-top:12px; display:block;">Notes:</label>
          <textarea id="trial-notes"
            aria-label="Notes for this trial"
            placeholder="Type your notes here…"
            class="notes-textarea"
            style="margin-top:12px;"></textarea>

          <label for="trial-final-response" style="margin-top:12px; display:block;">Final Response:</label>
          <textarea id="trial-final-response"
            aria-label="Final response area"
            placeholder="Type your final response here…"
            class="notes-textarea"
            style="margin-top:6px; min-height:80px;"></textarea>

          <div class="center" style="margin-top:12px;">
            <button id="done-button" class="done-button">Continue</button>
          </div>
        </div>
      `;

      makeAppendOnly(document.getElementById('trial-notes'));
      makeAppendOnly(document.getElementById('trial-final-response'));

      const doneBtn = container.querySelector('#done-button');
      const trialTA = document.getElementById('trial-final-response');

      function updateTrialGate() {
        const ok = (trialTA.value || '').trim().length > 0;
        doneBtn.disabled = !ok;
        doneBtn.setAttribute('aria-disabled', String(!ok));
      }
      updateTrialGate();
      trialTA.addEventListener('input', updateTrialGate);

      doneBtn.addEventListener('click', () => {
        if (doneBtn.disabled) return; // defense-in-depth
        endTrial('user');
      });
    }

    // --------------------------------------
    // END OF TRIAL / BLOCK / STUDY
    // --------------------------------------
    function endTrial(reason = 'user') {
      if (!trialActive) return;
      trialActive = false;
      clearTrialTimer();

      // capture notes now (works for both user click and timeout)
      const trialNotes = (document.getElementById('trial-notes')?.value || '').trim();
      const trialFinalResponse = (document.getElementById('trial-final-response')?.value || '').trim();

      stopRecording(async () => {
        await VoiceFeedback.stop();

        const type = blocks[blockIndex];
        allProblemLogs.push({
          blockType: type,
          trialIndex: trialIndex + 1,
          promptId: currentPrompt?.id || null,
          startTime: problemStartTime,
          endTime: Date.now(),
          endedBy: reason,
          notes: trialNotes,
          finalResponse: trialFinalResponse
        });

        trialIndex++;
        if (trialIndex < N) loadTrial();
        else {
          blockIndex++;
          if (blockIndex < blocks.length) {
            document.getElementById('task-ui').style.display = 'none';
            loadBlock();
          } else {
            return showPreFinalSurvey();
          }
        }
      });
    }


    async function finishStudy(finalSurveyObj) {
      if (document.fullscreenElement) document.exitFullscreen().catch(()=>{});
      document.getElementById('task-ui').style.display = 'none';

      const inst = document.getElementById('instructions-screen');
      if (inst) inst.style.display = 'none';

      let end = document.getElementById('end-screen');
      if (!end) {
        // Failsafe: recreate if it was ever removed
        end = document.createElement('div');
        end.id = 'end-screen';
        end.innerHTML = `<p style="margin-bottom:24px;font-size:18px;">
          Thank you for participating.<br>You may now close this window.
        </p>`;
        document.body.appendChild(end);
      }
      
      const finalSurvey = finalSurveyObj || window.finalSurvey || null;
      const preFinalSurvey = window.preFinalSurvey || null;
      const puzzleData = {
        participantData,
        puzzleLogs: allProblemLogs,
        finalSurvey,
        preFinalSurvey
      };
      const timestamp = Date.now();
      const participantId = `P_${timestamp}_${Math.random().toString(36).substr(2, 9)}`;

      try {
        // Save to Firebase
        try {
          // 1. Upload audio files to Storage
          for (const { block, trial, blob } of audioChunks) {
            const path = `audio/${participantId}/block${block}_problem${trial}.webm`;
            const audioRef = ref(storage, path);

            // ensure rules match; fall back to a safe audio type
            const ct = (blob && blob.type) ? blob.type
                    : 'audio/webm'; // fallback for browsers that omit type

            await uploadBytes(audioRef, blob, { contentType: ct });
          }

          // 2. Save experiment data to Firestore
          const experimentData = {
            participantId,
            timestamp: serverTimestamp(),
            clientTimestamp: timestamp,
            participantData,
            puzzleLogs: allProblemLogs,
            finalSurvey,
            preFinalSurvey,
            audioFileCount: audioChunks.length,
            userAgent: navigator.userAgent
          };

          const docRef = await addDoc(collection(db, 'experiments'), experimentData);
          console.log('Data saved to Firebase with ID:', docRef.id);

        } catch (firebaseError) {
          console.error('Firebase save failed:', firebaseError);
          showError('Could not save to Firebase; will save locally instead.');
        }

        // Always create local ZIP as backup
        const zip = new JSZip();
        zip.file("puzzle_data.json", JSON.stringify(puzzleData, null, 2));
        audioChunks.forEach(({ block, trial, blob }) => {
          zip.file(`block${block}_problem${trial}.webm`, blob);
        });
        const zipBlob = await zip.generateAsync({ type: "blob" });
        saveAs(zipBlob, "combined_task_data_with_audio.zip");

      } catch (err) {
        console.error('Error in finishStudy:', err);
        showError('Some data saving failed, but study is complete.');
      } finally {
        end.style.display = 'block';
        end.setAttribute('tabindex', '-1');
        end.focus();
        document.addEventListener('keydown', onEndScreenKey, { once: true });
      }
    }

    function onEndScreenKey() {
      document.removeEventListener('keydown', onEndScreenKey);
      const end = document.getElementById('end-screen');
      end.innerHTML = `
        <p style="margin-bottom:16px; font-size:18px;">
          User pressed a key on end screen—trigger payment logic here!
        </p>
        <p style="font-size:14px; opacity:.8;">
          (This is where you’d redirect to your completion URL or call your payment API.)
        </p>
      `;
      // e.g. window.location.href = 'https://your-completion-url';
    }

    // --------------------------------------
    // START
    // --------------------------------------
    startIntro();
  </script>
  <footer class="site-footer">
    <div class="footer-content">
      <a href="https://support.microsoft.com/contactus">Contact Us</a>
      <a href="https://go.microsoft.com/fwlink/?LinkId=521839">Privacy & Cookies</a>
      <a href="https://go.microsoft.com/fwlink/?LinkID=246338">Terms of Use</a>
      <a href="https://go.microsoft.com/fwlink/?linkid=2196228%20">Trademarks</a>
      <span>© 2025 Microsoft</span>
    </div>
  </footer>
</body>
</html>